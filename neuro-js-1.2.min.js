class Cell{static RELU="relu";static LEAKYRELU="leakyrelu";static SIGMOID="sigmoid";static TANH="tanh";static LINEAR="linear";static TYPE_RECURRENT="recurrent";constructor(t,e=!1,r=!1,s=Cell.SIGMOID){this.setInput(0),this.setOutput(0),this.setTargetOutput(null),this.error=0,this.derivative=0,this.layer=t,this.isBias=e,this.isRecurrent=r,this.activation=[Cell.RELU,Cell.LEAKYRELU,Cell.SIGMOID,Cell.TANH,Cell.LINEAR].includes(s)?s:Cell.SIGMOID,this.active=!0}setInput(t){this.input=t}setOutput(t){this.output=t}setTargetOutput(t){this.targetOutput=t}setError(t){this.error=t}getError(){return this.error}getDerivative(){return this.derivative}getTargetOutput(){return this.targetOutput}calcError(){this.error=this.targetOutput-this.getOutput()}setActive(t){this.active=t}isActive(){return this.active}getOutput(){return this.output}calcOutput(t){return this.isActive()?(this.isBias?this.setOutput(1):this.setOutput(this.calcActivation(t)),this.derivative=this.calcDerivative(),this.getOutput()):(this.setOutput(0),this.getOutput())}calcActivation(t){switch(this.activation){case Cell.RELU:return t<0?0:t;case Cell.LEAKYRELU:return t<0?.1*t:t;case Cell.TANH:return(Math.pow(2.718,t)-Math.pow(2.718,-1*t))/(Math.pow(2.718,t)+Math.pow(2.718,-1*t));case Cell.LINEAR:return t;case Cell.SIGMOID:default:return 1/(1+Math.pow(2.718,-1*t))}}calcDerivative(){switch(this.activation){case Cell.RELU:return this.getOutput()>0?1:0;case Cell.LEAKYRELU:return this.getOutput()>0?1:.1;case Cell.TANH:return 1-Math.pow(this.getOutput(),2);case Cell.LINEAR:return 1;case Cell.SIGMOID:default:return this.getOutput()*(1-this.getOutput())}}}class Perceptron{constructor(t=.1,e=1e-4){this.cells=[],this.layers=[],this.totalError=0,this.learningRate=t,this.errorTrashold=e,this.dropoutRate=0,this.resetEpoch()}setLearningRate(t){this.learningRate=t}getLearningRate(){return this.learningRate}getErrorTrashold(){return this.errorTrashold}getEpoch(){return this.epoch}resetEpoch(){this.epoch=0}getNetError(){return this.totalError}addNeuron(t,e,r){this.cells.push({id:e,cell:t,links:[],layer:r+0}),this.indexLayers()}updateNeuron(t,e){this.cells[this.findNeuronIndexById(t)]=e,this.indexLayers()}getNeuron(t){return this.cells[this.findNeuronIndexById(t)]}findNeuronIndexById(t){return this.cells.findIndex((e=>e.id===t))}getNeuronsByLayer(t){return this.cells.filter((e=>e.layer===t))}getRecurrentNeurones(){return this.cells.filter((t=>!0===t.cell.isRecurrent))}indexLayers(){this.layers=[];for(let t=0;t<this.cells.length;t++)this.layers.includes(this.cells[t].layer)||this.layers.push(this.cells[t].layer);this.layers.sort()}getNeuronLinks(t,e="right"){let r=[],s=t.links.filter((t=>t.type===e));for(let t=0;t<s.length;t++)r.push({neuron:this.getNeuron(s[t].id),weight:s[t].weight});return r}link(t,e,r=Math.random()){let s=this.getNeuron(t),i=this.getNeuron(e);s.links.push({id:e,weight:r,type:"right"}),i.links.push({id:t,weight:r,type:"left"}),this.updateNeuron(t,s),this.updateNeuron(e,i)}unlink(t,e){let r=this.getNeuron(t),s=this.getNeuron(e);r.links=r.links.filter((t=>t.id!==e)),s.links=s.links.filter((e=>e.id!==t)),this.updateNeuron(t,r),this.updateNeuron(e,s)}linkAll(){for(let t=0;t<this.layers.length-1;t++){let e=this.getNeuronsByLayer(this.layers[t]),r=this.getNeuronsByLayer(this.layers[t+1]);for(let t=0;t<e.length;t++){let s=this.getNeuron(e[t].id);for(let t=0;t<r.length;t++){let e=this.getNeuron(r[t].id);e.cell.isBias||e.cell.isRecurrent||this.link(s.id,e.id)}}}}createLayers(t,e=!0){for(let e=0;e<t.length;e++){for(let r=0;r<t[e].size;r++){let s="h";0===e?s="x":e===t.length-1&&(s="y"),this.addNeuron(new Cell(e,!1,!1,t[e].activation??Cell.SIGMOID),s+e+r,e)}if(e!==t.length-1&&this.addNeuron(new Cell(e,!0),"b"+e+t[e].size,e),t[e].type===Cell.TYPE_RECURRENT&&e>0)for(let r=0;r<t[e].size;r++){let s="h";0===e?s="x":e===t.length-1&&(s="y"),s="r"+s,this.addNeuron(new Cell(e-1,!1,!0,t.activation??Cell.SIGMOID),s+e+r,e-1)}}e&&this.linkAll()}setInputVector(t){let e=this.getNeuronsByLayer(this.layers[0]);for(let r=0;r<e.length;r++){let s=e[r];s.cell.isBias||(s.cell.setInput(t[r]),this.updateNeuron(s.id,s))}}setRecurrentInputs(){let t=this.getRecurrentNeurones(Cell.TYPE_RECURRENT);for(let e=0;e<t.length;e++){let r=t[e],s=this.getNeuronLinks(r),i=this.getNeuron(s[e].neuron.id);r.cell.setInput(i.cell.getOutput()),this.updateNeuron(r.id,r)}}setOutputVector(t){let e=this.getNeuronsByLayer(this.layers[this.layers.length-1]);for(let r=0;r<e.length;r++){let s=e[r];s.cell.setTargetOutput(t[r]),this.updateNeuron(s.id,s)}}getOutputVector(){let t=this.getNeuronsByLayer(this.layers[this.layers.length-1]),e=[];for(let r=0;r<t.length;r++){let s=t[r];e.push(s.cell.getOutput())}return e}getWeights(){const t=[];for(let e=0;e<this.layers.length-1;e++){const r=[],s=this.getNeuronsByLayer(this.layers[e]);for(const t of s){if(t.cell.isBias)continue;const e=this.getNeuronLinks(t,"right").map((t=>({targetNeuron:t.neuron.id,weight:t.weight})));r.push({neuronId:t.id,weights:e})}t.push(r)}return t}setDropoutRate(t){this.dropoutRate=Math.max(0,Math.min(t,1))}applyDropout(){if(0!==this.dropoutRate)for(let t=1;t<this.layers.length-1;t++){this.getNeuronsByLayer(this.layers[t]).forEach((t=>{if(!t.cell.isBias){const e=Math.random()>this.dropoutRate;t.cell.setActive(e)}}))}}resetDropout(){for(let t=1;t<this.layers.length-1;t++){this.getNeuronsByLayer(this.layers[t]).forEach((t=>{t.cell.setActive(!0)}))}}forwardPass(){this.applyDropout(),this.setRecurrentInputs();for(let t=0;t<this.layers.length;t++){let e=this.layers[t],r=this.getNeuronsByLayer(e);for(let t=0;t<r.length;t++){let e=r[t],s=e.cell.input,i=this.getNeuronLinks(e,"left");for(let t=0;t<i.length;t++)s+=i[t].neuron.cell.getOutput()*i[t].weight;e.cell.calcOutput(s),this.updateNeuron(e.id,e)}}this.resetDropout()}calcErrors(t=null){this.totalError=0,this.epoch++;for(let e=this.layers.length-1;e>=0;e--){let r=this.getNeuronsByLayer(this.layers[e]);for(let s=0;s<r.length;s++){let i=r[s],l=this.getNeuronLinks(i,"right");if(e===this.layers.length-1)null!==t?i.cell.setError(t-i.cell.getOutput()):i.cell.setError(i.cell.getTargetOutput()-i.cell.getOutput());else{let t=0;for(let e=0;e<l.length;e++){t+=l[e].neuron.cell.getError()*l[e].weight}i.cell.setError(t)}this.updateNeuron(i.id,i),e!==this.layers.length-1||t||(this.totalError+=.5*Math.pow(i.cell.getTargetOutput()-i.cell.getOutput(),2))}}}updateWeights(){for(let t=0;t<this.layers.length;t++){let e=this.layers[t],r=this.getNeuronsByLayer(e);for(let t=0;t<r.length;t++){let e=r[t],s=this.getNeuronLinks(e,"right");for(let t=0;t<s.length;t++){let r=s[t].neuron,i=s[t].weight+r.cell.getDerivative()*r.cell.getError()*e.cell.getOutput()*this.learningRate;this.unlink(e.id,r.id),this.link(e.id,r.id,i)}}}}backPropagation(t=!1,e=null){this.calcErrors(e),this.updateWeights()}}